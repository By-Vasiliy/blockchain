// Code generated by easyjson for marshaling/unmarshaling. DO NOT EDIT.

package blockchain

import (
	json "encoding/json"
	easyjson "github.com/mailru/easyjson"
	jlexer "github.com/mailru/easyjson/jlexer"
	jwriter "github.com/mailru/easyjson/jwriter"
)

// suppress unused package warning
var (
	_ *json.RawMessage
	_ *jlexer.Lexer
	_ *jwriter.Writer
	_ easyjson.Marshaler
)

func easyjson71c7223aDecodeBlockchain(in *jlexer.Lexer, out *Value) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeString()
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "x":
			out.X = uint64(in.Uint64())
		case "y":
			out.Y = float64(in.Float64())
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjson71c7223aEncodeBlockchain(out *jwriter.Writer, in Value) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"x\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Uint64(uint64(in.X))
	}
	{
		const prefix string = ",\"y\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Float64(float64(in.Y))
	}
	out.RawByte('}')
}

// MarshalJSON supports json.Marshaler interface
func (v Value) MarshalJSON() ([]byte, error) {
	w := jwriter.Writer{}
	easyjson71c7223aEncodeBlockchain(&w, v)
	return w.Buffer.BuildBytes(), w.Error
}

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v Value) MarshalEasyJSON(w *jwriter.Writer) {
	easyjson71c7223aEncodeBlockchain(w, v)
}

// UnmarshalJSON supports json.Unmarshaler interface
func (v *Value) UnmarshalJSON(data []byte) error {
	r := jlexer.Lexer{Data: data}
	easyjson71c7223aDecodeBlockchain(&r, v)
	return r.Error()
}

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *Value) UnmarshalEasyJSON(l *jlexer.Lexer) {
	easyjson71c7223aDecodeBlockchain(l, v)
}
func easyjson71c7223aDecodeBlockchain1(in *jlexer.Lexer, out *Stats) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeString()
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "market_price_usd":
			out.MarketPriceUsd = float64(in.Float64())
		case "hash_rate":
			out.HashRate = float64(in.Float64())
		case "total_fees_btc":
			out.TotalFeesBtc = int64(in.Int64())
		case "n_btc_mined":
			out.NBtcMined = int64(in.Int64())
		case "n_tx":
			out.NTx = uint64(in.Uint64())
		case "n_blocks_mined":
			out.NBlocksMined = uint64(in.Uint64())
		case "minutes_between_blocks":
			out.MinutesBetweenBlocks = float64(in.Float64())
		case "totalbc":
			out.Totalbc = int64(in.Int64())
		case "n_blocks_total":
			out.NBlocksTotal = uint64(in.Uint64())
		case "estimated_transaction_volume_usd":
			out.EstimatedTransactionVolumeUsd = float64(in.Float64())
		case "blocks_size":
			out.BlocksSize = uint64(in.Uint64())
		case "miners_revenue_usd":
			out.MinersRevenueUsd = float64(in.Float64())
		case "nextretarget":
			out.Nextretarget = int64(in.Int64())
		case "difficulty":
			out.Difficulty = int64(in.Int64())
		case "estimated_btc_sent":
			out.EstimatedBtcSent = int64(in.Int64())
		case "miners_revenue_btc":
			out.MinersRevenueBtc = int64(in.Int64())
		case "total_btc_sent":
			out.TotalBtcSent = int64(in.Int64())
		case "trade_volume_btc":
			out.TradeVolumeBtc = float64(in.Float64())
		case "trade_volume_usd":
			out.TradeVolumeUsd = float64(in.Float64())
		case "timestamp":
			out.Timestamp = float64(in.Float64())
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjson71c7223aEncodeBlockchain1(out *jwriter.Writer, in Stats) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"market_price_usd\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Float64(float64(in.MarketPriceUsd))
	}
	{
		const prefix string = ",\"hash_rate\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Float64(float64(in.HashRate))
	}
	{
		const prefix string = ",\"total_fees_btc\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Int64(int64(in.TotalFeesBtc))
	}
	{
		const prefix string = ",\"n_btc_mined\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Int64(int64(in.NBtcMined))
	}
	{
		const prefix string = ",\"n_tx\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Uint64(uint64(in.NTx))
	}
	{
		const prefix string = ",\"n_blocks_mined\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Uint64(uint64(in.NBlocksMined))
	}
	{
		const prefix string = ",\"minutes_between_blocks\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Float64(float64(in.MinutesBetweenBlocks))
	}
	{
		const prefix string = ",\"totalbc\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Int64(int64(in.Totalbc))
	}
	{
		const prefix string = ",\"n_blocks_total\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Uint64(uint64(in.NBlocksTotal))
	}
	{
		const prefix string = ",\"estimated_transaction_volume_usd\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Float64(float64(in.EstimatedTransactionVolumeUsd))
	}
	{
		const prefix string = ",\"blocks_size\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Uint64(uint64(in.BlocksSize))
	}
	{
		const prefix string = ",\"miners_revenue_usd\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Float64(float64(in.MinersRevenueUsd))
	}
	{
		const prefix string = ",\"nextretarget\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Int64(int64(in.Nextretarget))
	}
	{
		const prefix string = ",\"difficulty\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Int64(int64(in.Difficulty))
	}
	{
		const prefix string = ",\"estimated_btc_sent\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Int64(int64(in.EstimatedBtcSent))
	}
	{
		const prefix string = ",\"miners_revenue_btc\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Int64(int64(in.MinersRevenueBtc))
	}
	{
		const prefix string = ",\"total_btc_sent\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Int64(int64(in.TotalBtcSent))
	}
	{
		const prefix string = ",\"trade_volume_btc\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Float64(float64(in.TradeVolumeBtc))
	}
	{
		const prefix string = ",\"trade_volume_usd\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Float64(float64(in.TradeVolumeUsd))
	}
	{
		const prefix string = ",\"timestamp\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Float64(float64(in.Timestamp))
	}
	out.RawByte('}')
}

// MarshalJSON supports json.Marshaler interface
func (v Stats) MarshalJSON() ([]byte, error) {
	w := jwriter.Writer{}
	easyjson71c7223aEncodeBlockchain1(&w, v)
	return w.Buffer.BuildBytes(), w.Error
}

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v Stats) MarshalEasyJSON(w *jwriter.Writer) {
	easyjson71c7223aEncodeBlockchain1(w, v)
}

// UnmarshalJSON supports json.Unmarshaler interface
func (v *Stats) UnmarshalJSON(data []byte) error {
	r := jlexer.Lexer{Data: data}
	easyjson71c7223aDecodeBlockchain1(&r, v)
	return r.Error()
}

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *Stats) UnmarshalEasyJSON(l *jlexer.Lexer) {
	easyjson71c7223aDecodeBlockchain1(l, v)
}
func easyjson71c7223aDecodeBlockchain2(in *jlexer.Lexer, out *Chart) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeString()
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "status":
			out.Status = string(in.String())
		case "name":
			out.Name = string(in.String())
		case "unit":
			out.Unit = string(in.String())
		case "period":
			out.Period = string(in.String())
		case "description":
			out.Description = string(in.String())
		case "values":
			if in.IsNull() {
				in.Skip()
				out.Values = nil
			} else {
				in.Delim('[')
				if out.Values == nil {
					if !in.IsDelim(']') {
						out.Values = make([]Value, 0, 4)
					} else {
						out.Values = []Value{}
					}
				} else {
					out.Values = (out.Values)[:0]
				}
				for !in.IsDelim(']') {
					var v1 Value
					(v1).UnmarshalEasyJSON(in)
					out.Values = append(out.Values, v1)
					in.WantComma()
				}
				in.Delim(']')
			}
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjson71c7223aEncodeBlockchain2(out *jwriter.Writer, in Chart) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"status\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.String(string(in.Status))
	}
	{
		const prefix string = ",\"name\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.String(string(in.Name))
	}
	{
		const prefix string = ",\"unit\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.String(string(in.Unit))
	}
	{
		const prefix string = ",\"period\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.String(string(in.Period))
	}
	{
		const prefix string = ",\"description\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.String(string(in.Description))
	}
	{
		const prefix string = ",\"values\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		if in.Values == nil && (out.Flags&jwriter.NilSliceAsEmpty) == 0 {
			out.RawString("null")
		} else {
			out.RawByte('[')
			for v2, v3 := range in.Values {
				if v2 > 0 {
					out.RawByte(',')
				}
				(v3).MarshalEasyJSON(out)
			}
			out.RawByte(']')
		}
	}
	out.RawByte('}')
}

// MarshalJSON supports json.Marshaler interface
func (v Chart) MarshalJSON() ([]byte, error) {
	w := jwriter.Writer{}
	easyjson71c7223aEncodeBlockchain2(&w, v)
	return w.Buffer.BuildBytes(), w.Error
}

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v Chart) MarshalEasyJSON(w *jwriter.Writer) {
	easyjson71c7223aEncodeBlockchain2(w, v)
}

// UnmarshalJSON supports json.Unmarshaler interface
func (v *Chart) UnmarshalJSON(data []byte) error {
	r := jlexer.Lexer{Data: data}
	easyjson71c7223aDecodeBlockchain2(&r, v)
	return r.Error()
}

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *Chart) UnmarshalEasyJSON(l *jlexer.Lexer) {
	easyjson71c7223aDecodeBlockchain2(l, v)
}
